package versions

import (
	"fmt"

	"github.com/apparentlymart/go-versions/versions/constraints"
)

// ParseVersion attempts to parse the given string as a semantic version
// specification, and returns the result if successful.
//
// If the given string is not parseable then an error is returned that is
// suitable for display directly to a hypothetical end-user that provided this
// version string, as long as they can read English.
func ParseVersion(s string) (Version, error) {
	spec, err := constraints.ParseExactVersion(s)
	if err != nil {
		return Unspecified, err
	}
	return versionFromExactVersionSpec(spec), nil
}

// MustParseVersion is the same as ParseVersion except that it will panic
// instead of returning an error.
func MustParseVersion(s string) Version {
	v, err := ParseVersion(s)
	if err != nil {
		panic(err)
	}
	return v
}

// MeetingConstraints returns a version set that contains all of the versions
// that meet the given constraints, specified using the Spec type from the
// constraints package.
//
// This function expects an internally-consistent Spec like what would be
// generated by that package's constraint parsers. Behavior is undefined --
// including the possibility of panics -- if specs are hand-created and the
// expected invariants aren't met.
func MeetingConstraints(spec constraints.Spec) Set {
	if spec == nil {
		return All
	}

	switch ts := spec.(type) {

	case constraints.VersionSpec:
		lowerBound, upperBound := ts.ConstraintBounds()
		switch lowerBound.Operator {
		case constraints.OpUnconstrained:
			return All
		case constraints.OpEqual:
			return Only(versionFromExactVersionSpec(lowerBound.Boundary))
		default:
			return AtLeast(
				versionFromExactVersionSpec(lowerBound.Boundary),
			).Intersection(
				OlderThan(versionFromExactVersionSpec(upperBound.Boundary)))
		}

	case constraints.SelectionSpec:
		lower := ts.Boundary.ConstrainToZero()
		if ts.Operator != constraints.OpEqual && ts.Operator != constraints.OpNotEqual {
			lower.Metadata = "" // metadata is only considered for exact matches
		}

		switch ts.Operator {
		case constraints.OpUnconstrained:
			// Degenerate case, but we'll allow it.
			return All
		case constraints.OpMatch:
			// The match operator uses the constraints implied by the
			// Boundary version spec as the specification.
			// Note that we discard "lower" in this case, because we do want
			// to match our metadata if it's specified.
			return MeetingConstraints(ts.Boundary)
		case constraints.OpEqual, constraints.OpNotEqual:
			set := Only(versionFromExactVersionSpec(lower))
			if ts.Operator == constraints.OpNotEqual {
				// We want everything _except_ what's in our set, then.
				set = All.Subtract(set)
			}
			return set
		case constraints.OpGreaterThan:
			return NewerThan(versionFromExactVersionSpec(lower))
		case constraints.OpGreaterThanOrEqual:
			return AtLeast(versionFromExactVersionSpec(lower))
		case constraints.OpLessThan:
			return OlderThan(versionFromExactVersionSpec(lower))
		case constraints.OpLessThanOrEqual:
			return AtMost(versionFromExactVersionSpec(lower))
		case constraints.OpGreaterThanOrEqualMinorOnly:
			upper := lower
			upper.Major.Num++
			upper.Minor.Num = 0
			upper.Patch.Num = 0
			upper.Prerelease = ""
			return AtLeast(
				versionFromExactVersionSpec(lower),
			).Intersection(
				OlderThan(versionFromExactVersionSpec(upper)))
		case constraints.OpGreaterThanOrEqualPatchOnly:
			upper := lower
			upper.Minor.Num++
			upper.Patch.Num = 0
			upper.Prerelease = ""
			return AtLeast(
				versionFromExactVersionSpec(lower),
			).Intersection(
				OlderThan(versionFromExactVersionSpec(upper)))
		default:
			panic(fmt.Errorf("unsupported constraints.SelectionOp %s", ts.Operator))
		}

	case constraints.UnionSpec:
		if len(ts) == 0 {
			return All
		}
		if len(ts) == 1 {
			return MeetingConstraints(ts[0])
		}
		union := make(setUnion, len(ts))
		for i, subSpec := range ts {
			union[i] = MeetingConstraints(subSpec).setI
		}
		return Set{setI: union}

	case constraints.IntersectionSpec:
		if len(ts) == 0 {
			return All
		}
		if len(ts) == 1 {
			return MeetingConstraints(ts[0])
		}
		intersection := make(setIntersection, len(ts))
		for i, subSpec := range ts {
			intersection[i] = MeetingConstraints(subSpec).setI
		}
		return Set{setI: intersection}

	default:
		// should never happen because the above cases are exhaustive for
		// all valid constraint implementations.
		panic(fmt.Errorf("unsupported constraints.Spec implementation %T", spec))
	}
}

// RequestedByConstraints is a more opinionated version of MeetingConstraints
// which applies some logic to ensure that prerelease versions are included
// only if explicitly requested.
//
// In practice this means that the returned set is the intersection of the
// spec constraints with the predefined set Released, with the extra special
// case that if the constraints are a finite set requesting a particular
// prerelease version then that exact version is also included.
func RequestedByConstraints(spec constraints.Spec) Set {
	requested := MeetingConstraints(spec)
	set := Released
	set = set.Intersection(requested)

	if requested.IsFinite() {
		for _, version := range requested.List() {
			if version.Prerelease != "" {
				set = set.Union(Only(version))
			}
		}
	}

	return set
}

// MeetingRubyStyleConstraints attempts to parse the given spec as a
// "Ruby-style" version constraint string, and returns the set of versions
// that match the constraint if successful.
//
// If unsuccessful, the error from the underlying parser is returned verbatim.
// Parser errors are suitable for showing to an end-user in situations where
// the given spec came from user input.
//
// "Ruby-style" here is not a promise of exact compatibility with rubygems
// or any other Ruby tools. Rather, it refers to this parser using a syntax
// that is intended to feel familiar to those who are familiar with rubygems
// syntax.
//
// Constraints are parsed in "multi" mode, allowing multiple comma-separated
// constraints that are combined with the Intersection operator. For more
// control over the parsing process, use the constraints package API directly
// and then call MeetingConstraints.
func MeetingRubyStyleConstraints(spec string) (Set, error) {
	s, err := constraints.ParseRubyStyleMulti(spec)
	if err != nil {
		return None, err
	}
	return MeetingConstraints(s), nil
}

// RequestedByRubyStyleConstraints is like MeetingRubyStyleConstraints but it
// applies the extra logic described for RequestedByConstraints.
func RequestedByRubyStyleConstraints(spec string) (Set, error) {
	s, err := constraints.ParseRubyStyleMulti(spec)
	if err != nil {
		return None, err
	}
	return RequestedByConstraints(s), nil
}

// MustMakeSet can be used to wrap any function that returns a set and an error
// to make it panic if an error occurs and return the set otherwise.
//
// This is intended for tests and other situations where input is from
// known-good constants.
func MustMakeSet(set Set, err error) Set {
	if err != nil {
		panic(err)
	}
	return set
}

func versionFromExactVersionSpec(spec constraints.VersionSpec) Version {
	return Version{
		Major:      spec.Major.Num,
		Minor:      spec.Minor.Num,
		Patch:      spec.Patch.Num,
		Prerelease: VersionExtra(spec.Prerelease),
		Metadata:   VersionExtra(spec.Metadata),
	}
}
